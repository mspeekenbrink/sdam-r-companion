# Structural Equation modelling with lavaan

There are several packages for `R` which allow you to estimate Structural Equation Models (SEM), including `sem` [@R-sem], `OpenMx` [@R-OpenMx], and `lavaan` [@R-lavaan]. Here, we will focus solely on `lavaan`.

## Lavaan

The name "lavaan" stands for "`la`tent `va`riable `an`alysis". It is a package which can estimate a wide-variety of SEM models, including path models without latent variables. It has a convenient and intuitive syntax to define SEM models and it is actively developed. That is why it has perhaps become the go-to `R` package for SEM analysis. Although the help files in the `R` package are not overly comprehensive, the [lavaan website](https://www.lavaan.ugent.be/) has a useful tutorial, and I suggest you check this out.

### The lavaan model syntax

In `lavaan`, SEM models can be specified via model formula's similar to those used in the `lm()` and `glm()` functions. However, there are some new operators (relational symbols) used to define (residual) covariances, and latent variables. The table below lists some common expressions in the lavaan syntax.

Formula   | Description 
-----------------------------------|------------------------------------------------------------------------
`v =~ y`     | latent variable `v` is defined and measured by `y` 
`v =~ y1 + y2 + y3`  | latent variable `v` is defined and measured by `y1`, `y2`, and `y3`
`v =~ 1 + y1 + y2 + y3`  | latent variable `v` is defined and measured by `y1`, `y2`, and `y3`, <br /> with the inclusion of an explicit intercept `1` to model the mean of `v`
`y ~ x`     | `y` is regressed on `x`, i.e. a causal relation from `x` to `y`
`y ~ b*x`     | `y` is regressed on `x`, with the slope of `x` labelled as `b`
`y ~ x1 + x2 + x3`     | `y` is regressed on `x1`, `x2` and `x3`,<br /> i.e. causal relations from `x1`, `x2`, and `x3` to `y`
`y ~ a*x1 + b*x2 + c*x3`  | regression with labelled slopes
`abc := a*b*c` | define a derived term `abc` as a function of the model parameters
`y1 ~~ y2` | (residual) co-variance between `y1` and `y2`
`y1 ~~ 0*y2` | fix the (residual) co-variance between `y1` and `y2` to 0
`y ~~ y` | (residual) variance for `y`
`y ~~ 0*y` | fix the (residual) variance for `y` to 0

### Model estimation

Under the hood, there is really only a single function used to define and estimate SEM models in the `lavaan` package, namely the `lavaan::lavaan()` function. But the `lavaan` package offers several wrappers around this function to make estimation of common SEM models more convenient. These wrappers set defaults for arguments in the `lavaan::lavaan()` function that are geared towards particular analyses. Amongst these are the `lavaan::sem()` function, and the `lavaan::cfa()` function.

### Extracting results

Once a model is estimated, you can use the `summary()` function on the object returned to get the basic parameter estimates and tests. This function provides the most important results. You can additionally get some of the more widely used fit indices by setting the argument `"fit.measures = TRUE"`. Other functions which can be called on a model fitted by `lavaan` are:

* `fitMeasures()`: this function returns a long list of model fit measures, only some of which (the more important ones) were discussed in the SDAM book
* `fitted()`: this function returns the model-implied variance-covariance matrix and mean vector. 
* `anova()`: When provided with a single model, this function returns the results of a likelihood-ratio test of the model against the saturated model. When supplied with multiple models, the function returns likelihood-ratio tests comparing these. This assumes the models are nested!

## Plotting SEM models with the `semPlot` package

The `semPlot` package [@R-semPlot] package provides a convenient way to plot SEM models fitted by `lavaan`. In principle, all that is needed to plot a `lavaan`-estimated object `mod` is a call to `semPlot::semPaths(mod)`. However, the default settings don't necessarily provide the best looking plots. But the `semPlot` package is very flexible, and by setting several arguments, it is possible to produce agreeable plots, although it will often require multiple attempts. Important arguments to the `semPlot::semPaths()` function are

* `object`: for our purposes, this is the object returned by `lavaan`
* `what`: this allows you to change the appearance of the arrows based on the parameter estimates. The default (`"path"`) just displays the arrows, but by setting this argument to `"est"` the linewidth of the arrows reflects the magnitude of the links. For more options, see `?semPlot::semPath`.
* `whatLabels`: This argument sets labels for the arrows. Some of the options are `"name"` (display the name of the link) and `"est"` (display the parameter estimates). For more options, see `?semPlot::semPath`.


## Path models

Path models can be defined and estimated with the `lavaan::sem()` function. Important arguments for this function are:

* `model`: A `string` providing the model description
* `data`: the `data.frame` in which all variables in the model description can be found
* `meanstructure` (passed onto the `lavaan` function): a `logical` value  (`TRUE` or `FALSE`) indicating whether the means of the variables should be estimated via intercept terms
* `conditional.x` (passed onto the `lavaan` function): a `logical` value (`TRUE` or `FALSE`) indicating whether the model should just consider the conditional distribution of the endogenous variables, conditional upon the exogenous variables. 
* `fixed.x` (passed onto the `lavaan` function): a `logical` value (`TRUE` or `FALSE`) indicating whether the exogenous variables should be considered as fixed (`TRUE` by default).
* `estimator` (passed onto the `lavaan` function): a `string` which can be `"ML"` for maximum likelihood, `"GLS"` for (normal theory) generalized least squares, `"WLS"` for weighted least squares (sometimes called ADF estimation), or other values. See `?lavOptions` for other possibilities.

Usually, it is fine to stick to the defaults, and just specify the `model` and `data` arguments.

### Regression models

A simple regression model can be estimated  as follows:
```{r SEM-simple-regression-structural-plot, fig.cap="Graphical representation of a simple regression model", fig.width=1.2*4, fig.height=1.2*1, out.width="80%"}
# load the data
data("trump2016", package="sdamr")
# exclude the outlying Columbia state
dat <- subset(trump2016,state != "District of Columbia")
# specify the model in lavaan syntax
mod_spec <- 'percent_Trump_votes ~ 1 + hate_groups_per_million'
# estimate the model
library("lavaan")
fmod <- lavaan::sem(mod_spec, data=dat)
```
We can then see the estimates and tests via the `summary()` function:
```{r}
summary(fmod)
```
The output of the `summary()` function first provides information about the way the model was estimated (by maximum likelihood or `"ML"` by default). Next, under `"Model Test User Model"` you will find the results of a likelihood-ratio test comparing the model to a saturated model. This test was referred to as the "overall model fit" test in the SDAM book. After this come the parameter estimates, standard errors, and Wald tests. These are displayed in the following order: causal regression effects (`"Regressions"`), intercepts (`"Intercepts"`), and (residual) variances ("`Variances"`).

If you want to plot the model, you can use the `semPaths()` function from the `semPlot` package:
```{r simple-regression-semPlot}
library(semPlot)
semPlot::semPaths(fmod)
```

The default plot is quite basic and does not look so nice. In the following code, I set the arguments `layout = tree2` and `rotation = 2` to make the plot go from left to right, disable the automatic shortening of variable names by setting `nCharNodes = 0`, increase the size of the observed (or "manifest") variables by setting `sizeMan=7` and a relatively smaller size for the constant intercepts by setting `sizeInt = 4`. To display the estimated values as part of the arrows, I also set `whatLabels = "est"`. There are many other tweaks possible, and it pays to play around with the `semPaths()` function to get the result you want. You should look at the `?semPaths` help file to see all the options available. Note that it is useful to rename your variables before calling `lavaan::sem()` to get better names of the variables in `semPlot()`, as I will do in the next example.
```{r}
semPlot::semPaths(fmod, layout="tree2", sizeMan=7, sizeInt = 4, normalize=FALSE, 
                  whatLabels="est", width=4, height=1, rotation=2, nCharNodes = 0)
```

The multiple regression model discussed in the SDAM book is defined in `lavaan` syntax as 

`like ~ 1 + attr + sinc + intel + fun + amb`

This specifies that `like` is predicted by (observed) variables `attr`, `sinc`, `intel`, `fun`, and `amb`. We also include and intercept via the `1` term in the formula. The model can be specified and estimated as follows:
```{r}
# load the data
data("speeddate", package="sdamr")
dat <- speeddate
# the following lines are just to get shorter names for the variables
# this is usefull for semPlot. There are better ways to do this though.
dat$like <- dat$other_like
dat$attr <- dat$other_attr
dat$sinc <- dat$other_sinc
dat$intel <- dat$other_intel
dat$fun <- dat$other_fun
dat$amb <- dat$other_amb
# the lavaan model specification
mod_spec <-   'like ~ 1 + attr + sinc + intel + fun + amb'
# estimate the model
fmod <- lavaan::sem(mod_spec, data=dat)
```
The results can again be obtained with the `summary()` function. Here we will supply the additional `"fit.measures = TRUE"` argument to get additional measures of model fit:
```{r}
# get the results
summary(fmod, fit.measures=TRUE)
```
Compared to the usual output, we now also get a likelihood-ratio test against a baseline model (`"Model Test Baseline Model"`), two fit indices (the CFI and TLI, the latter of which was discussed in the SDAM book), then the AIC and BIC measures, and then two other measures of model fit (the RMSEA and SRMR).

As before, we can get a graphical depiction of the model by using the `semPaths()` function from the `semPlot` package. In the code below, I'm additionally setting the argument `curvature=3` to make the arrows for the covariances between the exogenous predictors more spread out and easier to see:
```{r}
semPlot::semPaths(fmod, layout="tree", sizeMan=7, sizeInt = 4, style="ram", 
                  residuals=TRUE, rotation=1, intAtSide = FALSE, 
                  whatLabels = "est", nCharNodes = 0, curvature=3)
```

### Mediation models

The mediation models concerned the `legacy2015` data in the `sdamr` package, which we should load first:
```{r}
data("legacy2015", package="sdamr")
dat <- legacy2015 
```
The Full Mediation model for the relation between legacy motive, intention, and donation, is specified through separate formulas for `intention` and `donation`, which are on separate lines of the string that will be supplied to `lavaan`. We can also explicitly label the regression parameters, which will allow us to compute the indirect effect of `legacy` on `donation`
```{r}
mod1 <-   '
    intention ~ 1 + a*legacy
    donation ~ 1 + b*intention
    ab := a*b # indirect effect of legacy on donation
'
```
Here, we have specified that `intention` is caused by `legacy`, and `donation` by `intention`. We have also included an intercept for both endogenous variables. The model can be estimated as usual:
```{r}
fmod1 <- lavaan::sem(mod1, data=dat)
```
The results are:
```{r}
summary(fmod1, fit.measures=TRUE)
```
As we have defined a new parameter for the indirect effect of `legacy` on `donation`, the results also show the estimate of this new parameter under `"Defined Parameters"`, named `ab`. We even get a Wald test for the null-hypothesis that the indirect effect is equal to 0 (i.e. no mediation), which is rejected.

A longer list of fit indices can also be obtained via
```{r}
fitMeasures(fmod1)
```
although this is not as nicely presented as in `summary(..., fit.measures=TRUE)`.

A graphical depiction of the model is obtained as:
```{r}
semPlot::semPaths(fmod1, layout="tree", sizeMan=7, sizeInt = 4, style="ram", 
                  residuals=TRUE, rotation=2, intAtSide = FALSE, 
                  whatLabels = "est", nCharNodes = 0, normalize = FALSE)
```
Note I am setting the argument `"intAtSide = FALSE"` to create a better looking plot. You can compare the result with setting `"intAtSide = TRUE"` to see the effect of this setting.

The Partial Mediation model is specified again by separate formulas for `intention` and `donation`, but now we include two predictors for `donation`:
```{r}
mod2 <-   '
    intention ~ 1 + a*legacy
    donation ~ 1 + b*intention + c*legacy
    ab := a*b
'
fmod2 <- lavaan::sem(mod2, data=dat)
summary(fmod2, fit.measures=TRUE)
semPlot::semPaths(fmod2, layout="tree", sizeMan=7, sizeInt = 5, style="ram", 
         residuals=TRUE, rotation=2, intAtSide = FALSE, whatLabels = "est", 
         nCharNodes = 0, normalize=FALSE)
```
Finally, the Common Cause model can be specified by three formulas. The first two lines concern the regression equations. The third line (`donation ~~ 0*intention`) specifies that the (residual) covariance between `donation` and `intention` should be fixed to 0.  
```{r}
mod3 <-   '
    intention ~ 1 + legacy
    donation ~ 1 + legacy
    donation ~~ 0*intention
'
fmod3 <- lavaan::sem(mod3, data=dat)
summary(fmod3, fit.measures=TRUE)
semPlot::semPaths(fmod3, layout="tree", sizeMan=7, sizeInt = 5, style="ram", 
                  residuals=TRUE, rotation=2, intAtSide = FALSE, 
                  whatLabels = "est", nCharNodes = 0, normalize=FALSE)
```
We can obtain likelihood-ratio tests for nested models with the `anova()` function. For sample, we can compare the Full Mediation model to the Partial Mediation model with: 
```{r}
anova(fmod1, fmod2)
```
And we can compare the Common Cause model to the Partial Mediation model with:
```{r}
anova(fmod3, fmod2)
```
As the Partial Mediation model is saturated, these tests are equivalent to the model fit tests reported by the `summary()` function for `fmod1` and `fmod3`.

### A more complex path model

More complex path models can be estimated by including more formula's in the model specification. For example:
```{r}
mod_complex <-   '
    belief ~ 1 + education
    legacy ~ 1 + age
    income ~ 1 + age + education
    intention ~ 1 + belief + legacy + income
    donation ~ 1 + intention + income
'
fmod_complex <- lavaan::sem(mod_complex, data=legacy2015)
summary(fmod_complex)
```
To plot complex models like this, it may be useful to hide the constant (intercept) terms, which is achieved by setting `"intercepts" = FALSE` in the call to `semPlot::semPaths()`:
```{r}
semPlot::semPaths(fmod_complex, layout="tree2", sizeMan=7, sizeInt = 5, 
                  style="ram", intercepts=FALSE, residuals=TRUE, rotation=2, 
                  intAtSide = FALSE, whatLabels = "est", nCharNodes = 0, 
                  normalize=FALSE)
```

<!--
## Latent variables

Latent variables are defined in `lavaan` by the `=~` operator. 
-->

## Exploratory factor analysis with the `psych` package

We will just cover the very basics of Exploratory Factor Analysis (EFA) here. In EFA, each "factor" (which is a latent variable in the model) is related to all observed variables (sometimes also called the "manifest" variables). 

EFA is implemented in the `factanal()` function from the `stats` package (base R), and the `fa()` function in the `psych` package. We will focus on the latter function here. The `psych` package comes with various additional tools useful for EFA, and adheres to the conventions for EFA in psychology. 

### Determining the number of factors with Parallel Analysis

A first useful function implements so-called "parallel analysis" to determine the optimal number of underlying factors for a given set of observed variables. This method, whilst somewhat "hacky", tends to work reasonably well in practice.

We will use the `bfi` data from the `psychTools` package as an example.
```{r}
data(bfi, package="psychTools")
head(bfi)
```

Parallel analysis [see e.g. @hayton2004factor] focuses on the common variance "explained" by each factor. It uses so-called eigenvalues as the measure of common variance accounted for by the factors. An eigenvalue larger than 1 indicates that a factor accounts for more variance than that of a single variable (i.e. it accounts for shared variation between the variables). However, eigenvalues can be larger than 1 due to sampling error, even though a factor in reality does not account for substantial shared variation. Parallel analysis aims to compare the eigenvalues for factors to those of random data (where there is no shared variation). According to parallel analysis, the optimal number of factors is the number of factors that have larger eigenvalues than would be obtained for random data.

A parallel analysis can be conducted via the `fa.parallel()` function from the `psych()` package. The first argument to this function, called `x`, can be either a `data.frame` containing just the variables you want to include in the EFA, or a correlation matrix. In a second argument, called `fa`, you can specify that you want to use EFA (`fa="fa"`), a principal components analysis (`fa="pc"`), or both (`fa="both"`). Here, we will just ask for a factor analysis. On the first line of the code below, we first exclude the last three columns (`gender`, `education`, and `age`) from the data, and then ask for a parallel analysis:
```{r}
dat <- bfi[,-c(26:28)]
psych::fa.parallel(dat, fa="fa")
```
The plot shows the eigenvalues for the different factors (ordered in magnitude) as blue triangles, and eigenvalues for random data as red lines. There is also a message indicating the optimal number of factors according to the analysis, which is 6, as there are six blue triangles above the red line.

We could obtain the same result via a correlation matrix, which can be computed with the `cor()` function. Note that if there are missing values in the data, by default this would return a missing value in the correlation matrix. We can avoid this by explicitly stating how we want to deal with missing variables (in this case, for each pair of variables, use the complete cases). 
```{r}
# compute correlation matrix from pairwise complete cases
bfi_cor <- cor(bfi[,-c(26:28)], use="pairwise.complete.obs")
```
If you use a correlation matrix, you should also specify the number of observations used to compute the correlation. A lower bound on this can be computed via the `complete.cases()` function, which returns a logical vector with each element equaling `TRUE` when all variables in a row of the data are not missing. By summing up these logical values (`TRUE` has value 1, and `FALSE` value 0), you get the number of complete cases.
```{r}
n_obs <- sum(complete.cases(bfi[,-c(26:28)]))
```
We can now finally perform the analysis:
```{r}
psych::fa.parallel(bfi_cor, n.obs=n_obs, fa="fa")
```
Note that there is nothing to be gained from using a correlation matrix rather than the "raw" data. However, it is instructive to see that EFA only needs a correlation matrix.

### Estimating and rotating EFA solutions

EFA can be performed via the `fa()` function from the `psych` package. Like the `psych::fa.parallel()` function, the first argument, now called `r`, can be a `data.frame` or a correlation or covariance matrix. The second argument, called `nfactors`, is used to set how many factors you want to include in the model. A further argument, called `rotate`, is used to set the rotation method. By default, this is *Oblimin* rotation, a form of *oblique* rotation. There are many other options (see the help file `?psych::fa`), including `"none"` (no rotation), `"varimax"` (a popular form of orthogonal rotation), and `"promax"` (a popular form of oblique rotation). The argument `fm` is used to specify the estimation method, for which we will use `fm="ml"` to obtain maximum likelihood estimation.

Here is an example without rotation:
```{r}
psych::fa(bfi[,-c(26:28)], nfactors = 6, rotate="none", fm="ml")
```
The output is rather extensive. A key table is the first one, with standardized factor loadings in the columns labelled `ML`.

You can just check the factor loadings via the `stat::loadings()` function. This allows you to not print loadings below a certain value (e.g. .10), by setting the `cutoff` argument. Below we will show the loadings obtained after *Varimax* rotation:
```{r}
bfi_fa <- psych::fa(bfi[,-c(26:28)], nfactors = 6, rotate="varimax", fm="ml")
loadings(bfi_fa, cutoff=.1)
```
Note that the factors are ordered according to how much variance they explain. In this case, the second factor `ML2` accounts for the most variance. A different solution is obtained with *Promax* rotation:
```{r}
bfi_fa <- psych::fa(bfi[,-c(26:28)], nfactors = 6, rotate="promax", fm="ml")
loadings(bfi_fa, cutoff=.1)
```

## Confirmatory factor analysis

Confirmatory Factor Analysis (CFA) can be performed via the `cfa()` function in the `lavaan` package. This function is very much like the `sem()` function, but uses different defaults. A main thing to supply is a specification of the model in the lavaan syntax.

Factors can be specified with the `=~` operator. On the right-hand side of this operator, you can specify a name for the factor, and on the left hand side you can specify which observed variables load onto the factor (i.e. which observed variables are partially caused by the factor), separated by a "+" sign. For instance, the line
```
agreeableness =~ A1 + A2 + A3 + A4 + A5
```
specifies that a latent factor called "agreeableness" accounts for shared variation in observed variables `A1`, `A2`, `A3`, `A4`, and `A5`. 

The following code specifies a CFA with a simple structure, in the sense that each observed variable only loads onto one factor:
```{r}
bfi_cfa_spec <- '
  # factor specification
    agreeableness =~ A1 + A2 + A3 + A4 + A5
    conscientiousness =~  C1 + C2 + C3 + C4 + C5
    extraversion =~  E1 + E2 + E3 + E4 + E5
    neuroticism =~ N1 + N2 + N3 + N4 + N5
    openness =~ O1 + O2 + O3 + O4 + O5
'
```

Using this lavaan model specification, the model can be estimated with the `lavaan::cfa()` function:
```{r}
bfi_cfa <- lavaan::cfa(bfi_cfa_spec, data=bfi)
```

Having estimated the model, we can obtain parameter estimates and tests via the `summary` function:
```{r}
summary(bfi_cfa, fit.measures=TRUE)
```
Note that for the `summary()` function to work, you need to have loaded the `lavaan` package with `library(lavaan)`.

A plot can again be obtained with the `semPlot::semPaths()` function
```{r, fig.width=12, fig.height=6}
semPlot::semPaths(bfi_cfa, layout="tree", sizeMan=3, residuals=TRUE, rotation=1, whatLabels = "est", nCharNodes = 5, normalize=TRUE, width=12, height=6)
```

Note that by default, factors are allowed to correlate. If you want to obtain a solution for uncorrelated factors, you need to explicitly fix the covariances between the factors to 0. This can be done via the `~~` operator, and multiplying the factors on the right-hand side of this operator to 0. For example, the line
```
agreeableness ~~ 0*conscientiousness + 0*extraversion + 0*neuroticism + 0*openness
```
specifies that the covariance between factor `agreeableness` and `conscientiousness` is 0 (`agreeableness ~~ 0*conscientiousness`), as well as the covariance between factor `agreeableness` and `extraversion`, `neuroticism`, and `openness`. You should only fix a covariance once, so you should not also have a line which states e.g.
```
conscientiousness ~~ 0*agreeableness
```
as this would lead to an error. The model specification below fixes the covariance for all pairs of factors to 0:
```{r}
bfi_cfa2_spec <-   '
  # factor specification
    agreeableness =~ A1 + A2 + A3 + A4 + A5
    conscientiousness =~  C1 + C2 + C3 + C4 + C5
    extraversion =~  E1 + E2 + E3 + E4 + E5
    neuroticism =~ N1 + N2 + N3 + N4 + N5
    openness =~ O1 + O2 + O3 + O4 + O5
  # fix factor covariances to 0
    agreeableness ~~ 0*conscientiousness + 0*extraversion + 0*neuroticism + 0*openness
    conscientiousness ~~ 0*extraversion + 0*neuroticism + 0*openness
    extraversion ~~ 0*neuroticism + 0*openness
    neuroticism ~~ 0*openness
'
```
Using this specification, the results are:
```{r}
bfi_cfa2 <- lavaan::cfa(bfi_cfa2_spec, data=bfi)
summary(bfi_cfa2, fit.measures=TRUE)
```

The model plot indicates the fixed covariances with dotted lines:
```{r}
semPlot::semPaths(bfi_cfa2, layout="tree", sizeMan=5, sizeInt = 5, style="ram", intercepts=FALSE, residuals=TRUE, rotation=1, intAtSide = FALSE, whatLabels = "est", nCharNodes = 5, normalize=TRUE, width=12, height=6)
```

## Modification indices

Modification indices can be obtained with the `modificationIndices()` from the `lavaan` package. Modification indices estimated the (positive) change in overall model fit when estimating, rather than fixing a parameter to a specific value. This change is provided in terms of the Chi-squared statistic ($X^2$), which under the null-hypothesis is distributed with $\text{df}=1$. 

For a given model, there are generally a lot of these indices, as many parameters might be fixed. By default, the `lavaan::modificationIndices()` functions also displays the expected change in the parameter value, including various standardized measures of such change. By setting the argument `standardized = FALSE`, these values are excluded, providing slightly more succinct output. An example providing *all* modification indices for the CFA model with uncorrelated factors is given in the code below. Be ready for lots of output!
```{r}
lavaan::modificationIndices(bfi_cfa2, standardized = FALSE) 
```

The argument `minimum.value` can be used to exclude modification indices below a certain value. For example, we might only be interested in modification indices above 20. In addition, it can be useful to order the output by the magnitude of the modification index, showing the most promising parameters first, This can be obtained by setting the argument `sort.` to `TRUE`.  Below, we do both to get some idea of possible parameters which might be useful to allow to be estimated. This still provides many modification indices, but at least a few less.
```{r}
lavaan::modificationIndices(bfi_cfa2, minimum.value = 20, sort.=TRUE, standardized = FALSE) 
```

An important thing to remember when inspecting these modification indices is that each indicates what would happen to the model if a single parameter is estimated rather than fixed. If you would include e.g. a residual covariance between `agreableness` and `extraversion`, as suggested by the highest modification index, then the model would change and therefore the resulting modification indices of that modified model would be different from those of the current model. Hence, it does not necessarily make sense to change all fixed variables according to the modification indices. If you are willing to change a model in an exploratory way, this should be a sequential procedure, adding one estimated parameter and then inspecting the modification indices again. It is also important to keep in mind that such sequential procedures don't necessarily lead to the best possible model. 

## General SEM models

General SEM models can be estimated with the `lavaan:sem()` function. As in the `lavaan::cfa()` function, this allows you to specify latent variables via the `=~` operator. You can also specify further path regressions, linking observed variables to other observed variables and/or to factors. As an example, we will analyse data from the speed dating experiment, which is available in the `sdamr` package as `speeddate`.

In this example, we will focus on ratings by participants on how physically attractive (`date_attr`), fun (`date_fun`), sincere (`date_sinc`), intelligent (`date_intel`), and ambitious (`date_amb`) they find them, as well as a rating of their overall liking of their date (`date_like`). The dating partner also provided the same ratings for the participants (same variables, but with `other_` prepended). 

In this first model, we will assume that more "frivolous" aspects of a potential partner (e.g. physical attractiveness and fun) are treated as distinct from more serious aspects of a potential partner (e.g., intelligence, ambition, and sincerity). This can be formalized in a SEM model by assuming different latent variables for each. By formulating these as latent variables, we can also determine the weight of each of the observed variables in determining the latent variables (via the factor loadings).

In the model below, we assume whether a person likes their date also depends on the reciprocal liking by their date of them. This is implemented by assuming that e.g. `date_like` is causally linked to the four latent variables `d_frivolous`, `d_serious`, `o_frivolous`, and `o_serious`. A similar assumption is made for `other_like`.

```{r}
# load the data
data("speeddate", package="sdamr")

# specify the model
speed_mod_spec <- '
  # define latent variables
  d_frivolous =~ date_attr + date_fun
  d_serious =~ date_sinc + date_intel + date_amb

  o_frivolous =~ other_attr + other_fun
  o_serious =~ other_sinc + other_intel + other_amb

  # regressions
  date_like ~ d_frivolous + d_serious + o_frivolous + o_serious
  other_like ~ o_frivolous + o_serious + d_frivolous + d_serious
'

# estimate the model
speed_mod <- lavaan::sem(speed_mod_spec, data=speeddate)
```

The structural relations can be depicted with the code below. Note that we set various arguments in the `semPlot::semPaths()` function. To get a nice looking plot for your own data, it will pay to try different values of this. The `semPaths()` function is very flexible, but doesn't generally provide the best looking plots by default. You **should** have a look at the help file to see all the possible options to make the plot look better (i.e. by typing `?semPlot::semPaths`).

```{r}
semPlot::semPaths(speed_mod, layout="tree2", sizeMan=7, residuals=TRUE, whatLabels = "est", nCharNodes = 12, normalize=TRUE, width=12, height=6)
```

The parameter estimates and tests, as well as additional fit measures for the model, are obtained as:
```{r}
summary(speed_mod, fit.measures = TRUE)
```

These results indicate that there is potentially little covariance between the latent variables for the participants (`d_frivolous` and `d_serious`) and for their dates (`other_frivolous` and `other_serious`). However, the "frivolous" and "serious" aspects of participants do appear correlated, and similarly for their dates. 

These correlations can be captured by assuming residual covariances between factors are non-zero, but also by assuming a **hierarchical factor** structure, where a latent variable higher up in the structure determines the values of the latent variables below in the structure. The lavaan syntax allows you to specify such higher-order latent variables with the same `=~` operator, by naming the higher-order latent variable on the left-hand side, and the latent variables that load onto this higher-order latent variable on the right-hand side. In the model below, we assume that it is these higher-order latent variables which "cause" the overall liking of each person by their dating partner (`date_like` and `other_like`).

```{r, echo=FALSE}
# speed_mod2_spec <- '
#   # define latent variables
#   d_frivolous =~ date_attr + date_fun
#   d_serious =~ date_sinc + date_intel + date_amb
#   
#   o_frivolous =~ other_attr + other_fun
#   o_serious =~ other_sinc + other_intel + other_amb
# 
#   # regressions
#   date_like ~ d_frivolous + d_serious 
#   other_like ~ o_frivolous + o_serious
# 
#   # fix covariances to 0
#   date_like ~~ 0*other_like
#   d_frivolous~~ 0*o_frivolous + 0*o_serious
#   d_serious~~ 0*o_frivolous + 0*o_serious
# '
# speed_mod2 <- lavaan::sem(speed_mod2_spec, data=speeddate)
```

```{r}
speed_mod2_spec <- '
  # define latent variables
  d_frivolous =~ date_attr + date_fun
  d_serious =~ date_sinc + date_intel + date_amb
  d_overall =~ d_frivolous + d_serious

  o_frivolous =~ other_attr + other_fun
  o_serious =~ other_sinc + other_intel + other_amb
  o_overall =~ o_frivolous + o_serious
  
  # regressions
  date_like ~ d_overall
  other_like ~ o_overall
  
  # covariances
  date_like ~~ 0*other_like
'
speed_mod2 <- lavaan::sem(speed_mod2_spec, data=speeddate)
```

A plot of the model is obtained via:
```{r}
semPlot::semPaths(speed_mod2, layout="tree2", sizeMan=7, residuals=TRUE, whatLabels = "est", nCharNodes = 12, normalize=TRUE, width=12, height=6)
```

The parameter estimates and tests, as well as additional fit measures for the model, are obtained as:
```{r}
summary(speed_mod2, fit.measures = TRUE)
```

